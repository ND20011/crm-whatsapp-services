const express = require('express');
const { authenticateToken, requireActiveClient, logAccess } = require('../middleware/auth');
const MessageService = require('../services/MessageService');
const BotQuotaService = require('../services/BotQuotaService');
const TemplateController = require('../controllers/TemplateController');
const BulkMessageController = require('../controllers/BulkMessageController');

const router = express.Router();

// ============================================================================
// MESSAGES ROUTES - CRM CONDORITO
// ============================================================================

/**
 * GET /api/messages/bot/quota/debug
 * Debug endpoint temporal sin autenticaci√≥n
 */
router.get('/bot/quota/debug', async (req, res, next) => {
    try {
        console.log('üîç DEBUG: Iniciando diagn√≥stico de bot quota...');
        
        // Ejecutar sincronizaci√≥n
        await MessageService.syncBotUsageFromHistory();
        
        // Obtener todos los clientes para mostrar su estado
        const { executeQuery } = require('../config/database-simple');
        const clients = await executeQuery(`
            SELECT id, client_code, monthly_bot_limit, current_bot_usage, bot_usage_reset_date 
            FROM clients
        `);
        
        console.log('üìä Estado de todos los clientes:', clients);
        
        res.json({
            success: true,
            message: 'Debug completado - revisa los logs del servidor',
            clients: clients
        });
        
    } catch (error) {
        console.error('‚ùå Error en debug:', error.message);
        res.json({
            success: false,
            error: error.message,
            stack: error.stack
        });
    }
});

// Aplicar autenticaci√≥n a todas las rutas de mensajes
router.use(authenticateToken);
router.use(requireActiveClient);
router.use(logAccess);

// ============================================================================
// CONVERSATIONS - IMPLEMENTADO
// ============================================================================

/**
 * GET /api/messages/conversations
 * Obtener lista de conversaciones del cliente
 */
router.get('/conversations', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const {
            limit = 50,
            offset = 0,
            archived = false,
            search = null
        } = req.query;

        const options = {
            limit: parseInt(limit),
            offset: parseInt(offset),
            archived: archived === 'true',
            search: search || null
        };

        const conversations = await MessageService.getConversations(clientId, options);

        res.status(200).json({
            success: true,
            conversations,
            pagination: {
                limit: options.limit,
                offset: options.offset,
                total: conversations.length
            }
        });

    } catch (error) {
        console.error('‚ùå Error getting conversations:', error.message);
        next(error);
    }
});

/**
 * GET /api/messages/conversation/:id
 * Obtener mensajes de una conversaci√≥n espec√≠fica
 */
router.get('/conversation/:id', async (req, res, next) => {
    try {
        const { id: conversationId } = req.params;
        const {
            limit = 50,
            offset = 0,
            messageType = null,
            senderType = null
        } = req.query;

        const options = {
            limit: parseInt(limit),
            offset: parseInt(offset),
            messageType: messageType || null,
            senderType: senderType || null
        };

        const messages = await MessageService.getMessages(parseInt(conversationId), options);

        res.status(200).json({
            success: true,
            messages,
            conversation_id: parseInt(conversationId),
            pagination: {
                limit: options.limit,
                offset: options.offset,
                total: messages.length
            }
        });

    } catch (error) {
        console.error('‚ùå Error getting messages:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/conversation/:id/read
 * Marcar conversaci√≥n como le√≠da
 */
router.post('/conversation/:id/read', async (req, res, next) => {
    try {
        const { id: conversationId } = req.params;

        const success = await MessageService.markConversationAsRead(parseInt(conversationId));

        if (success) {
            // Emitir estad√≠sticas actualizadas por WebSocket
            try {
                const clientId = req.user?.id;
                const clientCode = req.user?.client_code;
                
                if (clientId && clientCode) {
                    const updatedStats = await MessageService.getMessageStats(clientId);
                    const socketIo = req.app.get('socketio');
                    
                    if (socketIo) {
                        const roomName = `client_${clientCode}`;
                        console.log(`üìä Emitting stats:updated to room: ${roomName} (mark as read)`);
                        
                        socketIo.to(roomName).emit('stats:updated', {
                            clientCode,
                            stats: updatedStats,
                            timestamp: new Date()
                        });
                    }
                }
            } catch (error) {
                console.error('Error emitting stats update after mark as read:', error);
            }

            res.status(200).json({
                success: true,
                message: 'Conversaci√≥n marcada como le√≠da',
                conversation_id: parseInt(conversationId)
            });
        } else {
            res.status(400).json({
                success: false,
                message: 'No se pudo marcar la conversaci√≥n como le√≠da'
            });
        }

    } catch (error) {
        console.error('‚ùå Error marking conversation as read:', error.message);
        next(error);
    }
});

/**
 * DELETE /api/messages/conversation/:id
 * Eliminar conversaci√≥n completa (conversaci√≥n y todos sus mensajes)
 */
router.delete('/conversation/:id', async (req, res, next) => {
    try {
        const { id: conversationId } = req.params;
        const clientId = req.user.id;
        
        console.log(`üóëÔ∏è Eliminando conversaci√≥n ID: ${conversationId} para cliente ID: ${clientId}`);
        
        const { executeQuery } = require('../config/database-simple');
        const Conversation = require('../entities/Conversation');
        
        // Verificar que la conversaci√≥n existe y pertenece al cliente
        const conversation = await executeQuery(
            'SELECT * FROM conversations WHERE id = ? AND client_id = ?',
            [parseInt(conversationId), clientId]
        );
        
        if (conversation.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Conversaci√≥n no encontrada'
            });
        }
        
        // Eliminar todos los mensajes de la conversaci√≥n
        console.log(`üóëÔ∏è Eliminando mensajes de la conversaci√≥n ${conversationId}`);
        await executeQuery(
            'DELETE FROM messages WHERE conversation_id = ?',
            [parseInt(conversationId)]
        );
        
        // Eliminar la conversaci√≥n
        console.log(`üóëÔ∏è Eliminando conversaci√≥n ${conversationId}`);
        await executeQuery(
            'DELETE FROM conversations WHERE id = ? AND client_id = ?',
            [parseInt(conversationId), clientId]
        );
        
        console.log(`‚úÖ Conversaci√≥n ${conversationId} eliminada exitosamente`);
        
        // Emitir evento por WebSocket para actualizar la UI en tiempo real
        const socketIo = req.app.get('socketio');
        if (socketIo) {
            const clientCode = req.user.clientCode;
            const roomName = `client_${clientCode}`;
            console.log(`üì° Emitting conversation:deleted to room: ${roomName}`);
            socketIo.to(roomName).emit('conversation:deleted', {
                clientCode,
                conversationId: parseInt(conversationId),
                timestamp: new Date()
            });
        }
        
        res.status(200).json({
            success: true,
            message: 'Conversaci√≥n eliminada exitosamente',
            conversation_id: parseInt(conversationId)
        });
        
    } catch (error) {
        console.error('‚ùå Error deleting conversation:', error.message);
        next(error);
    }
});

/**
 * GET /api/messages/search
 * Buscar mensajes por contenido
 */
router.get('/search', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const {
            q: searchTerm,
            limit = 50,
            offset = 0,
            conversationId = null
        } = req.query;

        if (!searchTerm) {
            return res.status(400).json({
                success: false,
                message: 'Par√°metro de b√∫squeda "q" es requerido'
            });
        }

        const options = {
            limit: parseInt(limit),
            offset: parseInt(offset),
            conversationId: conversationId ? parseInt(conversationId) : null
        };

        const messages = await MessageService.searchMessages(clientId, searchTerm, options);

        res.status(200).json({
            success: true,
            messages,
            search_term: searchTerm,
            pagination: {
                limit: options.limit,
                offset: options.offset,
                total: messages.length
            }
        });

    } catch (error) {
        console.error('‚ùå Error searching messages:', error.message);
        next(error);
    }
});

// ============================================================================
// SEND MESSAGES - IMPLEMENTADO B√ÅSICO
// ============================================================================

/**
 * POST /api/messages/send
 * Enviar mensaje individual (redirige a WhatsApp controller)
 */
router.post('/send', (req, res) => {
    // Redirigir al endpoint de WhatsApp que ya est√° implementado
    res.status(200).json({
        success: true,
        message: 'Use POST /api/whatsapp/send-message para enviar mensajes',
        redirect: 'POST /api/whatsapp/send-message'
    });
});

/**
 * POST /api/messages/send-bulk
 * Enviar mensajes masivos (legacy endpoint - redirige a campaigns)
 */
router.post('/send-bulk', (req, res) => {
    res.status(200).json({
        success: true,
        message: 'Usa POST /api/messages/campaigns para crear campa√±as de mensajes masivos',
        redirect: 'POST /api/messages/campaigns',
        new_endpoints: {
            create_campaign: 'POST /api/messages/campaigns',
            preview_contacts: 'POST /api/messages/campaigns/preview',
            send_campaign: 'POST /api/messages/campaigns/:id/send'
        }
    });
});

// ============================================================================
// STATISTICS - IMPLEMENTADO
// ============================================================================

/**
 * GET /api/messages/stats
 * Obtener estad√≠sticas de mensajes
 */
router.get('/stats', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { hours = 24 } = req.query;

        const stats = await MessageService.getMessageStats(clientId, {
            hours: parseInt(hours)
        });

        res.status(200).json({
            success: true,
            stats
        });

    } catch (error) {
        console.error('‚ùå Error getting message stats:', error.message);
        next(error);
    }
});

// ============================================================================
// TEMPLATES - ETAPA 4 ‚úÖ COMPLETADO
// ============================================================================

/**
 * GET /api/messages/templates
 * Obtener templates de mensajes del cliente
 */
router.get('/templates', TemplateController.getTemplates);

/**
 * GET /api/messages/templates/categories
 * Obtener categor√≠as disponibles
 */
router.get('/templates/categories', TemplateController.getCategories);

/**
 * GET /api/messages/templates/stats
 * Obtener estad√≠sticas de uso de templates
 */
router.get('/templates/stats', TemplateController.getTemplateStats);

/**
 * GET /api/messages/templates/:id
 * Obtener template espec√≠fico por ID
 */
router.get('/templates/:id', TemplateController.getTemplateById);

/**
 * POST /api/messages/templates
 * Crear nuevo template de mensaje
 */
router.post('/templates', TemplateController.createTemplate);

/**
 * POST /api/messages/templates/:id/preview
 * Generar preview del template con variables personalizadas
 */
router.post('/templates/:id/preview', TemplateController.previewTemplate);

/**
 * POST /api/messages/templates/:id/use
 * Usar template (incrementar contador de uso)
 */
router.post('/templates/:id/use', TemplateController.useTemplate);

/**
 * POST /api/messages/templates/duplicate/:id
 * Duplicar template existente
 */
router.post('/templates/duplicate/:id', TemplateController.duplicateTemplate);

/**
 * PUT /api/messages/templates/:id
 * Actualizar template de mensaje
 */
router.put('/templates/:id', TemplateController.updateTemplate);

/**
 * PUT /api/messages/templates/:id/toggle
 * Activar/desactivar template
 */
router.put('/templates/:id/toggle', TemplateController.toggleTemplate);

/**
 * DELETE /api/messages/templates/:id
 * Eliminar template de mensaje
 */
router.delete('/templates/:id', TemplateController.deleteTemplate);

// ============================================================================
// BULK MESSAGES / CAMPAIGNS - ETAPA 4 ‚úÖ COMPLETADO
// ============================================================================

/**
 * GET /api/messages/campaigns
 * Obtener lista de campa√±as de mensajes masivos
 */
router.get('/campaigns', BulkMessageController.getCampaigns);

/**
 * GET /api/messages/campaigns/stats
 * Obtener estad√≠sticas de campa√±as
 */
router.get('/campaigns/stats', BulkMessageController.getCampaignStats);

/**
 * GET /api/messages/campaigns/statuses
 * Obtener estados disponibles para campa√±as
 */
router.get('/campaigns/statuses', BulkMessageController.getCampaignStatuses);

/**
 * POST /api/messages/campaigns/preview
 * Previsualizar selecci√≥n de contactos para campa√±a
 */
router.post('/campaigns/preview', BulkMessageController.previewContactSelection);

/**
 * GET /api/messages/campaigns/:id
 * Obtener campa√±a espec√≠fica por ID
 */
router.get('/campaigns/:id', BulkMessageController.getCampaignById);

/**
 * POST /api/messages/campaigns
 * Crear nueva campa√±a de mensajes masivos
 */
router.post('/campaigns', BulkMessageController.createCampaign);

/**
 * PUT /api/messages/campaigns/:id
 * Actualizar campa√±a existente
 */
router.put('/campaigns/:id', BulkMessageController.updateCampaign);

/**
 * DELETE /api/messages/campaigns/:id
 * Eliminar campa√±a
 */
router.delete('/campaigns/:id', BulkMessageController.deleteCampaign);

/**
 * POST /api/messages/campaigns/:id/send
 * Enviar campa√±a inmediatamente
 */
router.post('/campaigns/:id/send', BulkMessageController.sendCampaign);

/**
 * POST /api/messages/campaigns/:id/cancel
 * Cancelar campa√±a
 */
router.post('/campaigns/:id/cancel', BulkMessageController.cancelCampaign);

// ============================================================================
// BOT CONTROL - GLOBAL
// ============================================================================

/**
 * POST /api/messages/bot/enable-all
 * Activar bot para todas las conversaciones del cliente
 */
router.post('/bot/enable-all', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        // Activar bot para todas las conversaciones del cliente
        const result = await executeQuery(
            'UPDATE conversations SET bot_enabled = 1, updated_at = NOW() WHERE client_id = ?',
            [clientId]
        );
        
        console.log(`ü§ñ Bot enabled for all conversations of client ${clientId}`);
        
        res.status(200).json({
            success: true,
            message: 'Bot activado para todas las conversaciones',
            affected_conversations: result.affectedRows,
            client_id: clientId
        });
        
    } catch (error) {
        console.error('‚ùå Error enabling bot for all conversations:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/bot/disable-all
 * Desactivar bot para todas las conversaciones del cliente
 */
router.post('/bot/disable-all', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        // Desactivar bot para todas las conversaciones del cliente
        const result = await executeQuery(
            'UPDATE conversations SET bot_enabled = 0, updated_at = NOW() WHERE client_id = ?',
            [clientId]
        );
        
        console.log(`üö´ Bot disabled for all conversations of client ${clientId}`);
        
        res.status(200).json({
            success: true,
            message: 'Bot desactivado para todas las conversaciones',
            affected_conversations: result.affectedRows,
            client_id: clientId
        });
        
    } catch (error) {
        console.error('‚ùå Error disabling bot for all conversations:', error.message);
        next(error);
    }
});

/**
 * GET /api/messages/bot/status
 * Obtener estad√≠sticas del estado del bot
 */
router.get('/bot/status', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        // Obtener estad√≠sticas del bot
        const [stats] = await executeQuery(`
            SELECT 
                COUNT(*) as total_conversations,
                SUM(CASE WHEN bot_enabled = 1 THEN 1 ELSE 0 END) as bot_enabled_conversations,
                SUM(CASE WHEN bot_enabled = 0 THEN 1 ELSE 0 END) as bot_disabled_conversations,
                ROUND((SUM(CASE WHEN bot_enabled = 1 THEN 1 ELSE 0 END) / COUNT(*)) * 100, 2) as bot_enabled_percentage
            FROM conversations 
            WHERE client_id = ?
        `, [clientId]);
        
        res.status(200).json({
            success: true,
            bot_status: {
                total_conversations: stats?.total_conversations || 0,
                bot_enabled_conversations: stats?.bot_enabled_conversations || 0,
                bot_disabled_conversations: stats?.bot_disabled_conversations || 0,
                bot_enabled_percentage: stats?.bot_enabled_percentage || 0,
                client_id: clientId
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error getting bot status:', error.message);
        next(error);
    }
});

// ============================================================================
// BOT CONTROL - POR CONVERSACI√ìN
// ============================================================================

/**
 * POST /api/messages/conversation/:id/bot/enable
 * Activar bot para una conversaci√≥n espec√≠fica
 */
router.post('/conversation/:id/bot/enable', async (req, res, next) => {
    try {
        const { id: conversationId } = req.params;
        const clientId = req.user.id;
        
        const Conversation = require('../entities/Conversation');
        const conversation = await Conversation.findById(parseInt(conversationId));
        
        if (!conversation) {
            return res.status(404).json({
                success: false,
                message: 'Conversaci√≥n no encontrada'
            });
        }
        
        // Verificar que la conversaci√≥n pertenece al cliente
        if (conversation.client_id !== clientId) {
            return res.status(403).json({
                success: false,
                message: 'No tienes permisos para modificar esta conversaci√≥n'
            });
        }
        
        await conversation.setBotEnabled(true);
        
        console.log(`ü§ñ Bot enabled for conversation ${conversationId} (${conversation.contact_phone})`);
        
        res.status(200).json({
            success: true,
            message: 'Bot activado para esta conversaci√≥n',
            conversation: {
                id: conversation.id,
                contact_phone: conversation.contact_phone,
                contact_name: conversation.contact_name,
                bot_enabled: true
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error enabling bot for conversation:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/conversation/:id/bot/disable
 * Desactivar bot para una conversaci√≥n espec√≠fica
 */
router.post('/conversation/:id/bot/disable', async (req, res, next) => {
    try {
        const { id: conversationId } = req.params;
        const clientId = req.user.id;
        
        const Conversation = require('../entities/Conversation');
        const conversation = await Conversation.findById(parseInt(conversationId));
        
        if (!conversation) {
            return res.status(404).json({
                success: false,
                message: 'Conversaci√≥n no encontrada'
            });
        }
        
        // Verificar que la conversaci√≥n pertenece al cliente
        if (conversation.client_id !== clientId) {
            return res.status(403).json({
                success: false,
                message: 'No tienes permisos para modificar esta conversaci√≥n'
            });
        }
        
        await conversation.setBotEnabled(false);
        
        console.log(`üö´ Bot disabled for conversation ${conversationId} (${conversation.contact_phone})`);
        
        res.status(200).json({
            success: true,
            message: 'Bot desactivado para esta conversaci√≥n',
            conversation: {
                id: conversation.id,
                contact_phone: conversation.contact_phone,
                contact_name: conversation.contact_name,
                bot_enabled: false
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error disabling bot for conversation:', error.message);
        next(error);
    }
});

/**
 * GET /api/messages/conversation/:id/bot/status
 * Obtener estado del bot para una conversaci√≥n espec√≠fica
 */
router.get('/conversation/:id/bot/status', async (req, res, next) => {
    try {
        const { id: conversationId } = req.params;
        const clientId = req.user.id;
        
        const Conversation = require('../entities/Conversation');
        const conversation = await Conversation.findById(parseInt(conversationId));
        
        if (!conversation) {
            return res.status(404).json({
                success: false,
                message: 'Conversaci√≥n no encontrada'
            });
        }
        
        // Verificar que la conversaci√≥n pertenece al cliente
        if (conversation.client_id !== clientId) {
            return res.status(403).json({
                success: false,
                message: 'No tienes permisos para acceder a esta conversaci√≥n'
            });
        }
        
        res.status(200).json({
            success: true,
            conversation: {
                id: conversation.id,
                contact_phone: conversation.contact_phone,
                contact_name: conversation.contact_name,
                bot_enabled: conversation.bot_enabled,
                last_message_at: conversation.last_message_at
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error getting bot status for conversation:', error.message);
        next(error);
    }
});

// ============================================================================
// BOT CONFIGURATION - HORARIOS Y CONFIGURACI√ìN
// ============================================================================

/**
 * GET /api/messages/bot/disabled-conversations
 * Obtener lista de conversaciones con bot desactivado
 */
router.get('/bot/disabled-conversations', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { limit = 50, offset = 0 } = req.query;
        
        const { executeQuery } = require('../config/database-simple');
        
        // Validar y sanitizar los valores de limit y offset
        const safeLimit = Math.max(1, Math.min(100, parseInt(limit))); // Entre 1 y 100
        const safeOffset = Math.max(0, parseInt(offset)); // M√≠nimo 0
        
        // Obtener conversaciones con bot desactivado
        const query = `
            SELECT c.id, c.contact_phone, c.contact_name, c.last_message, 
                   c.last_message_at, c.unread_count, c.bot_enabled,
                   c.created_at, c.updated_at
            FROM conversations c
            WHERE c.client_id = ? AND c.bot_enabled = 0
            ORDER BY c.last_message_at DESC
            LIMIT ${safeLimit} OFFSET ${safeOffset}
        `;
        
        const conversations = await executeQuery(query, [clientId]);
        
        // Contar total de conversaciones con bot desactivado
        const countQuery = `
            SELECT COUNT(*) as total 
            FROM conversations 
            WHERE client_id = ? AND bot_enabled = 0
        `;
        const countResult = await executeQuery(countQuery, [clientId]);
        const total = countResult[0].total;
        
        console.log(`üìã Found ${conversations.length} conversations with bot disabled for client ${clientId}`);
        
        res.status(200).json({
            success: true,
            data: conversations,
            pagination: {
                total,
                limit: parseInt(limit),
                offset: parseInt(offset),
                hasMore: (parseInt(offset) + conversations.length) < total
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error getting disabled bot conversations:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/bot/enable-conversations
 * Activar bot para conversaciones espec√≠ficas
 */
router.post('/bot/enable-conversations', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { conversation_ids } = req.body;
        
        if (!conversation_ids || !Array.isArray(conversation_ids) || conversation_ids.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'Se requiere un array de IDs de conversaciones'
            });
        }
        
        const { executeQuery } = require('../config/database-simple');
        
        // Verificar que todas las conversaciones pertenecen al cliente
        const placeholders = conversation_ids.map(() => '?').join(',');
        const verifyQuery = `
            SELECT id, contact_phone, contact_name 
            FROM conversations 
            WHERE client_id = ? AND id IN (${placeholders})
        `;
        
        const verifyParams = [clientId, ...conversation_ids];
        const existingConversations = await executeQuery(verifyQuery, verifyParams);
        
        if (existingConversations.length !== conversation_ids.length) {
            return res.status(400).json({
                success: false,
                message: 'Algunas conversaciones no existen o no pertenecen a tu cuenta'
            });
        }
        
        // Activar bot para las conversaciones especificadas
        const updateQuery = `
            UPDATE conversations 
            SET bot_enabled = 1, updated_at = NOW() 
            WHERE client_id = ? AND id IN (${placeholders})
        `;
        
        const result = await executeQuery(updateQuery, verifyParams);
        
        console.log(`ü§ñ Bot enabled for ${result.affectedRows} conversations of client ${clientId}`);
        
        res.status(200).json({
            success: true,
            message: `Bot activado para ${result.affectedRows} conversaciones`,
            affected_conversations: result.affectedRows,
            conversations: existingConversations
        });
        
    } catch (error) {
        console.error('‚ùå Error enabling bot for specific conversations:', error.message);
        next(error);
    }
});

/**
 * GET /api/messages/bot/config
 * Obtener configuraci√≥n actual del bot
 */
router.get('/bot/config', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        // Obtener configuraci√≥n del bot
        const results = await executeQuery(
            'SELECT * FROM bot_configurations WHERE client_id = ?',
            [clientId]
        );
        
        let botConfig;
        if (results.length === 0) {
            // Crear configuraci√≥n por defecto si no existe
            await executeQuery(`
                INSERT INTO bot_configurations 
                (client_id, is_enabled, working_hours_start, working_hours_end, working_days, 
                 auto_response_delay, fallback_message, max_auto_responses_per_conversation, product_search_enabled) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                clientId, 
                true, 
                '00:00:00', 
                '23:59:00', 
                JSON.stringify([0, 1, 2, 3, 4, 5, 6]), // Todos los d√≠as
                2000, 
                'Lo siento, no pude entender tu consulta. Un agente te contactar√° pronto.',
                5,
                false  // Por defecto, solo respuestas de texto (sin b√∫squeda de productos)
            ]);
            
            // Obtener la configuraci√≥n reci√©n creada
            const newResults = await executeQuery(
                'SELECT * FROM bot_configurations WHERE client_id = ?',
                [clientId]
            );
            botConfig = newResults[0];
        } else {
            botConfig = results[0];
        }
        
        // Parsear working_days si es string
        if (typeof botConfig.working_days === 'string') {
            try {
                botConfig.working_days = JSON.parse(botConfig.working_days);
            } catch (e) {
                botConfig.working_days = [1, 2, 3, 4, 5];
            }
        }
        
        res.status(200).json({
            success: true,
            bot_config: {
                id: botConfig.id,
                client_id: botConfig.client_id,
                is_enabled: botConfig.is_enabled,
                working_hours: {
                    start: botConfig.working_hours_start,
                    end: botConfig.working_hours_end,
                    days: botConfig.working_days
                },
                settings: {
                    auto_response_delay: botConfig.auto_response_delay,
                    max_auto_responses_per_conversation: botConfig.max_auto_responses_per_conversation,
                    fallback_message: botConfig.fallback_message,
                    welcome_message: botConfig.welcome_message,
                    custom_instructions: botConfig.custom_instructions,
                    product_search_enabled: botConfig.product_search_enabled
                },
                created_at: botConfig.created_at,
                updated_at: botConfig.updated_at
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error getting bot configuration:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/bot/toggle
 * Alternar estado global del bot (habilitar/deshabilitar)
 */
router.post('/bot/toggle', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        // Obtener configuraci√≥n actual
        const currentConfig = await executeQuery(
            'SELECT is_enabled FROM bot_configurations WHERE client_id = ?',
            [clientId]
        );
        
        let newStatus;
        if (currentConfig.length === 0) {
            // Crear configuraci√≥n por defecto si no existe (habilitado)
            await executeQuery(`
                INSERT INTO bot_configurations 
                (client_id, is_enabled, working_hours_start, working_hours_end, working_days, 
                 auto_response_delay, fallback_message, max_auto_responses_per_conversation, product_search_enabled) 
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            `, [
                clientId, 
                false, // Lo creamos deshabilitado ya que el usuario quiere togglear
                '00:00:00', 
                '23:59:00', 
                JSON.stringify([0, 1, 2, 3, 4, 5, 6]),
                2000, 
                'Lo siento, no pude entender tu consulta. Un agente te contactar√° pronto.',
                5,
                false
            ]);
            newStatus = false;
        } else {
            // Alternar el estado actual
            newStatus = !currentConfig[0].is_enabled;
            await executeQuery(
                'UPDATE bot_configurations SET is_enabled = ?, updated_at = NOW() WHERE client_id = ?',
                [newStatus, clientId]
            );
        }
        
        console.log(`ü§ñ Cliente ${req.user.client_code} ${newStatus ? 'habilit√≥' : 'deshabilit√≥'} el bot globalmente`);
        
        res.status(200).json({
            success: true,
            message: `Bot ${newStatus ? 'habilitado' : 'deshabilitado'} globalmente`,
            data: {
                is_enabled: newStatus,
                status: newStatus ? 'enabled' : 'disabled'
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error toggling bot status:', error.message);
        next(error);
    }
});

/**
 * PUT /api/messages/bot/config
 * Actualizar configuraci√≥n del bot
 */
router.put('/bot/config', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        const {
            is_enabled,
            working_hours_start,
            working_hours_end,
            working_days,
            auto_response_delay,
            max_auto_responses_per_conversation,
            fallback_message,
            welcome_message,
            custom_instructions,
            product_search_enabled
        } = req.body;
        
        // Validar horarios
        if (working_hours_start && !/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(working_hours_start)) {
            return res.status(400).json({
                success: false,
                message: 'Formato de hora de inicio inv√°lido. Use HH:MM (ej: 09:00)'
            });
        }
        
        if (working_hours_end && !/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(working_hours_end)) {
            return res.status(400).json({
                success: false,
                message: 'Formato de hora de fin inv√°lido. Use HH:MM (ej: 18:00)'
            });
        }
        
        // Validar d√≠as de trabajo
        if (working_days && (!Array.isArray(working_days) || !working_days.every(day => day >= 0 && day <= 6))) {
            return res.status(400).json({
                success: false,
                message: 'D√≠as de trabajo inv√°lidos. Use array de n√∫meros 0-6 (0=Domingo, 1=Lunes, etc.)'
            });
        }
        
        // Construir query de actualizaci√≥n din√°micamente
        const updateFields = [];
        const updateValues = [];
        
        if (is_enabled !== undefined) {
            updateFields.push('is_enabled = ?');
            updateValues.push(is_enabled);
        }
        
        if (working_hours_start) {
            updateFields.push('working_hours_start = ?');
            updateValues.push(working_hours_start + ':00');
        }
        
        if (working_hours_end) {
            updateFields.push('working_hours_end = ?');
            updateValues.push(working_hours_end + ':00');
        }
        
        if (working_days) {
            updateFields.push('working_days = ?');
            updateValues.push(JSON.stringify(working_days));
        }
        
        if (auto_response_delay !== undefined) {
            updateFields.push('auto_response_delay = ?');
            updateValues.push(auto_response_delay);
        }
        
        if (max_auto_responses_per_conversation !== undefined) {
            updateFields.push('max_auto_responses_per_conversation = ?');
            updateValues.push(max_auto_responses_per_conversation);
        }
        
        if (fallback_message !== undefined) {
            updateFields.push('fallback_message = ?');
            updateValues.push(fallback_message);
        }
        
        if (welcome_message !== undefined) {
            updateFields.push('welcome_message = ?');
            updateValues.push(welcome_message);
        }
        
        if (custom_instructions !== undefined) {
            updateFields.push('custom_instructions = ?');
            updateValues.push(custom_instructions);
        }
        
        if (product_search_enabled !== undefined) {
            updateFields.push('product_search_enabled = ?');
            updateValues.push(product_search_enabled);
        }
        
        if (updateFields.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'No se proporcionaron campos para actualizar'
            });
        }
        
        // Agregar updated_at
        updateFields.push('updated_at = NOW()');
        updateValues.push(clientId);
        
        // Ejecutar actualizaci√≥n
        const result = await executeQuery(
            `UPDATE bot_configurations SET ${updateFields.join(', ')} WHERE client_id = ?`,
            updateValues
        );
        
        if (result.affectedRows === 0) {
            return res.status(404).json({
                success: false,
                message: 'Configuraci√≥n del bot no encontrada'
            });
        }
        
        // Obtener configuraci√≥n actualizada
        const updatedConfig = await executeQuery(
            'SELECT * FROM bot_configurations WHERE client_id = ?',
            [clientId]
        );
        
        const botConfig = updatedConfig[0];
        
        // Parsear working_days
        if (typeof botConfig.working_days === 'string') {
            try {
                botConfig.working_days = JSON.parse(botConfig.working_days);
            } catch (e) {
                botConfig.working_days = [1, 2, 3, 4, 5];
            }
        }
        
        console.log(`‚öôÔ∏è Bot configuration updated for client ${clientId}`);
        
        res.status(200).json({
            success: true,
            message: 'Configuraci√≥n del bot actualizada correctamente',
            bot_config: {
                id: botConfig.id,
                client_id: botConfig.client_id,
                is_enabled: botConfig.is_enabled,
                working_hours: {
                    start: botConfig.working_hours_start,
                    end: botConfig.working_hours_end,
                    days: botConfig.working_days
                },
                settings: {
                    auto_response_delay: botConfig.auto_response_delay,
                    max_auto_responses_per_conversation: botConfig.max_auto_responses_per_conversation,
                    fallback_message: botConfig.fallback_message,
                    welcome_message: botConfig.welcome_message,
                    custom_instructions: botConfig.custom_instructions
                },
                updated_at: botConfig.updated_at
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error updating bot configuration:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/bot/config/reset
 * Resetear configuraci√≥n del bot a valores por defecto
 */
router.post('/bot/config/reset', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        // Resetear a configuraci√≥n por defecto
        const result = await executeQuery(`
            UPDATE bot_configurations 
            SET is_enabled = ?, 
                working_hours_start = ?, 
                working_hours_end = ?, 
                working_days = ?, 
                auto_response_delay = ?, 
                max_auto_responses_per_conversation = ?, 
                fallback_message = ?, 
                welcome_message = NULL, 
                custom_instructions = NULL,
                product_search_enabled = ?,
                updated_at = NOW()
            WHERE client_id = ?
        `, [
            true,
            '00:00:00',
            '23:59:00',
            JSON.stringify([0, 1, 2, 3, 4, 5, 6]),
            2000,
            5,
            'Lo siento, no pude entender tu consulta. Un agente te contactar√° pronto.',
            false,  // Por defecto, solo respuestas de texto (sin b√∫squeda de productos)
            clientId
        ]);
        
        if (result.affectedRows === 0) {
            return res.status(404).json({
                success: false,
                message: 'Configuraci√≥n del bot no encontrada'
            });
        }
        
        console.log(`üîÑ Bot configuration reset to defaults for client ${clientId}`);
        
        res.status(200).json({
            success: true,
            message: 'Configuraci√≥n del bot restablecida a valores por defecto',
            bot_config: {
                is_enabled: true,
                working_hours: {
                    start: '00:00:00',
                    end: '23:59:00',
                    days: [0, 1, 2, 3, 4, 5, 6]
                },
                settings: {
                    auto_response_delay: 2000,
                    max_auto_responses_per_conversation: 5,
                    fallback_message: 'Lo siento, no pude entender tu consulta. Un agente te contactar√° pronto.',
                    welcome_message: null,
                    custom_instructions: null
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error resetting bot configuration:', error.message);
        next(error);
    }
});

/**
 * GET /api/messages/bot/config/working-hours/status
 * Verificar si el bot est√° en horario de trabajo actualmente
 */
router.get('/bot/config/working-hours/status', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const MessageService = require('../services/MessageService');
        
        // Obtener configuraci√≥n del bot
        const botConfig = await MessageService.getBotConfiguration(clientId);
        
        if (!botConfig) {
            return res.status(404).json({
                success: false,
                message: 'Configuraci√≥n del bot no encontrada'
            });
        }
        
        // Verificar si est√° en horario de trabajo
        const isWorkingHours = MessageService.isBotWorkingHours(botConfig);
        
        // Informaci√≥n adicional
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        const currentDay = now.getDay();
        
        const dayNames = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
        
        let workingDays;
        try {
            workingDays = botConfig.working_days ? JSON.parse(botConfig.working_days) : [1, 2, 3, 4, 5];
        } catch (e) {
            workingDays = [1, 2, 3, 4, 5];
        }
        
        res.status(200).json({
            success: true,
            working_hours_status: {
                is_working_hours: isWorkingHours,
                is_bot_enabled: botConfig.is_enabled,
                current_time: {
                    hour: currentHour,
                    minute: currentMinute,
                    day: currentDay,
                    day_name: dayNames[currentDay],
                    formatted: `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`
                },
                configured_hours: {
                    start: botConfig.working_hours_start,
                    end: botConfig.working_hours_end,
                    working_days: workingDays,
                    working_days_names: workingDays.map(day => dayNames[day])
                },
                status_message: isWorkingHours && botConfig.is_enabled ? 
                    'Bot activo - En horario de trabajo' : 
                    !botConfig.is_enabled ? 
                        'Bot deshabilitado' : 
                        'Bot inactivo - Fuera de horario de trabajo'
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error checking working hours status:', error.message);
        next(error);
    }
});

// ============================================================================

// HEALTH CHECK
// ============================================================================

/**
 * GET /api/messages/health
 * Health check espec√≠fico para el m√≥dulo de mensajes
 */
router.get('/health', async (req, res) => {
    try {
        // Verificar servicios relacionados
        const AIService = require('../services/AIService');
        const aiHealth = await AIService.healthCheck();

        res.json({
            module: 'messages',
            status: 'ACTIVE',
            timestamp: new Date().toISOString(),
            services: {
                message_service: 'active',
                ai_service: aiHealth.status
            },
            endpoints: {
                active: [
                    'GET /api/messages/conversations',
                    'GET /api/messages/conversation/:id',
                    'POST /api/messages/conversation/:id/read',
                    'GET /api/messages/search',
                    'GET /api/messages/stats',
                    'POST /api/messages/bot/enable-all',
                    'POST /api/messages/bot/disable-all',
                    'GET /api/messages/bot/status',
                    'POST /api/messages/conversation/:id/bot/enable',
                    'POST /api/messages/conversation/:id/bot/disable',
                    'GET /api/messages/conversation/:id/bot/status',
                    'GET /api/messages/bot/config',
                    'PUT /api/messages/bot/config',
                    'POST /api/messages/bot/config/reset',
                    'GET /api/messages/bot/config/working-hours/status'
                ],
                development: [
                    'POST /api/messages/send-bulk',
                    'GET /api/messages/templates',
                    'POST /api/messages/templates',
                    'PUT /api/messages/templates/:id',
                    'DELETE /api/messages/templates/:id'
                ]
            }
        });
    } catch (error) {
        res.status(500).json({
            module: 'messages',
            status: 'ERROR',
            timestamp: new Date().toISOString(),
            error: error.message
        });
    }
});

// ============================================================================
// TESTING ENDPOINTS (SIN AUTENTICACI√ìN - PARA DASHBOARD)
// ============================================================================

/**
 * GET /api/messages/bot/status/public
 * Endpoint p√∫blico para testing del estado del bot (sin autenticaci√≥n)
 */
router.get('/bot/status/public', async (req, res) => {
    try {
        console.log('üß™ Public bot status endpoint called');
        
        // Datos de ejemplo para testing
        const mockBotStatus = {
            enabled: true,
            responses: 47,
            responsesToday: 12,
            enabledConversations: 15,
            disabledConversations: 3,
            percentage: 83.33,
            productSearchEnabled: true
        };

        res.json({
            success: true,
            bot_status: {
                total_conversations: mockBotStatus.enabledConversations + mockBotStatus.disabledConversations,
                bot_enabled_conversations: mockBotStatus.enabledConversations,
                bot_disabled_conversations: mockBotStatus.disabledConversations,
                bot_enabled_percentage: mockBotStatus.percentage,
                responses_today: mockBotStatus.responsesToday,
                total_responses: mockBotStatus.responses,
                product_search_enabled: mockBotStatus.productSearchEnabled,
                status: mockBotStatus.enabled ? 'active' : 'inactive'
            },
            message: 'Bot status retrieved successfully (PUBLIC TEST ENDPOINT)'
        });
        
    } catch (error) {
        console.error('‚ùå Error in public bot status:', error.message);
        res.status(500).json({
            success: false,
            message: 'Error retrieving bot status',
            error: error.message
        });
    }
});

/**
 * GET /api/messages/bot/quota/public
 * Endpoint p√∫blico para testing de la cuota del bot (sin autenticaci√≥n)
 */
router.get('/bot/quota/public', async (req, res) => {
    try {
        console.log('üß™ Public bot quota endpoint called');
        
        // Datos de ejemplo para testing
        const mockQuota = {
            usage: 1847,
            limit: 2500,
            remaining: 653,
            percentage: 73.88,
            allowed: true,
            resetDate: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 1).toISOString()
        };

        res.json({
            success: true,
            quota: mockQuota,
            message: mockQuota.allowed 
                ? `Tienes ${mockQuota.remaining} respuestas autom√°ticas disponibles este mes`
                : 'L√≠mite mensual de respuestas autom√°ticas excedido'
        });
        
    } catch (error) {
        console.error('‚ùå Error in public bot quota:', error.message);
        res.status(500).json({
            success: false,
            message: 'Error retrieving bot quota',
            error: error.message
        });
    }
});

// ============================================================================
// WHATSAPP STATUS PUBLIC ENDPOINT
// ============================================================================

/**
 * GET /api/messages/whatsapp/status/public
 * Endpoint p√∫blico para testing del estado de WhatsApp (sin autenticaci√≥n)
 */
router.get('/whatsapp/status/public', async (req, res) => {
    try {
        console.log('üß™ Public WhatsApp status endpoint called');
        
        // Datos de ejemplo para testing
        const mockWhatsAppStatus = {
            connected: true,
            phoneNumber: '+54911XXXXXXXX',
            clientInfo: {
                pushname: 'CRM Condorito',
                wid: 'demo@c.us'
            },
            lastSeen: new Date().toISOString(),
            battery: 85,
            plugged: true
        };

        res.json({
            success: true,
            status: 'connected',
            connected: mockWhatsAppStatus.connected,
            hasQR: false,
            phoneNumber: mockWhatsAppStatus.phoneNumber,
            clientInfo: mockWhatsAppStatus.clientInfo,
            data: mockWhatsAppStatus,
            message: 'WhatsApp status retrieved successfully (PUBLIC TEST ENDPOINT)'
        });
        
    } catch (error) {
        console.error('‚ùå Error in public WhatsApp status:', error.message);
        res.status(500).json({
            success: false,
            message: 'Error retrieving WhatsApp status',
            error: error.message
        });
    }
});

/**
 * POST /api/messages/bot/products/enable
 * Habilitar b√∫squeda de productos para el bot
 */
router.post('/bot/products/enable', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        const result = await executeQuery(`
            UPDATE bot_configurations 
            SET product_search_enabled = TRUE, updated_at = NOW()
            WHERE client_id = ?
        `, [clientId]);
        
        if (result.affectedRows === 0) {
            return res.status(404).json({
                success: false,
                message: 'Configuraci√≥n del bot no encontrada'
            });
        }
        
        res.json({
            success: true,
            message: 'B√∫squeda de productos habilitada correctamente',
            product_search_enabled: true
        });
        
    } catch (error) {
        console.error('‚ùå Error enabling product search:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/bot/products/disable
 * Deshabilitar b√∫squeda de productos para el bot
 */
router.post('/bot/products/disable', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        const result = await executeQuery(`
            UPDATE bot_configurations 
            SET product_search_enabled = FALSE, updated_at = NOW()
            WHERE client_id = ?
        `, [clientId]);
        
        if (result.affectedRows === 0) {
            return res.status(404).json({
                success: false,
                message: 'Configuraci√≥n del bot no encontrada'
            });
        }
        
        res.json({
            success: true,
            message: 'B√∫squeda de productos deshabilitada correctamente',
            product_search_enabled: false
        });
        
    } catch (error) {
        console.error('‚ùå Error disabling product search:', error.message);
        next(error);
    }
});

/**
 * GET /api/messages/bot/products/status
 * Obtener estado de la b√∫squeda de productos
 */
router.get('/bot/products/status', async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database-simple');
        
        const results = await executeQuery(
            'SELECT product_search_enabled FROM bot_configurations WHERE client_id = ?',
            [clientId]
        );
        
        if (results.length === 0) {
            return res.status(404).json({
                success: false,
                message: 'Configuraci√≥n del bot no encontrada'
            });
        }
        
        const productSearchEnabled = results[0].product_search_enabled;
        
        res.json({
            success: true,
            product_search_status: {
                enabled: productSearchEnabled,
                mode: productSearchEnabled ? 'Respuestas con b√∫squeda de productos' : 'Solo respuestas de texto',
                description: productSearchEnabled 
                    ? 'El bot puede buscar y mostrar productos de la base de datos'
                    : 'El bot solo responde con informaci√≥n del archivo de texto'
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error getting product search status:', error.message);
        next(error);
    }
});

// ============================================================================
// BOT QUOTA MANAGEMENT
// ============================================================================

/**
 * GET /api/messages/bot/quota
 * Obtener estado de cuota del bot
 */
router.get('/bot/quota', authenticateToken, logAccess, async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const clientCode = req.user.clientCode;
        
        console.log(`üìä Obteniendo quota para cliente ${clientCode} (ID: ${clientId})`);
        
        // Usar servicio centralizado en lugar del m√©todo deprecated
        const quotaStatus = await BotQuotaService.checkQuotaAvailable(clientCode);
        const usageStats = await MessageService.getBotUsageStats(clientId);
        
        console.log(`üìä quotaStatus:`, quotaStatus);
        console.log(`üìä usageStats:`, usageStats);
        
        res.json({
            success: true,
            quota: {
                // Informaci√≥n de mensajes
                usage: quotaStatus.usage || 0,
                limit: quotaStatus.limit || 2500,
                remaining: quotaStatus.remaining || 2500,
                percentage: quotaStatus.percentage || 0,
                // Informaci√≥n de tokens
                tokenUsage: quotaStatus.tokenUsage || 0,
                tokenLimit: quotaStatus.tokenLimit || 100000,
                tokensRemaining: quotaStatus.tokensRemaining || 100000,
                tokenPercentage: quotaStatus.tokenPercentage || 0,
                // Informaci√≥n general
                resetDate: usageStats.next_reset_date,
                status: quotaStatus.available ? "active" : "exceeded",
                allowed: quotaStatus.available,
                limits: quotaStatus.limits
            },
            message: quotaStatus.message || (
                quotaStatus.available 
                    ? `Tienes ${quotaStatus.remaining} mensajes y ${quotaStatus.tokensRemaining} tokens disponibles este mes`
                    : "L√≠mite mensual excedido"
            )
        });
        
    } catch (error) {
        console.error('‚ùå Error getting bot quota:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/bot/quota/sync
 * Sincronizar cuota del bot con el historial (endpoint temporal)
 */
router.post('/bot/quota/sync', authenticateToken, logAccess, async (req, res, next) => {
    try {
        console.log('üîÑ Iniciando sincronizaci√≥n manual de bot quota...');
        
        // Forzar sincronizaci√≥n
        await MessageService.syncBotUsageFromHistory();
        
        // Obtener estado actualizado usando servicio centralizado
        const clientId = req.user.id;
        const clientCode = req.user.clientCode;
        const quotaStatus = await BotQuotaService.checkQuotaAvailable(clientCode);
        
        res.json({
            success: true,
            message: 'Sincronizaci√≥n completada',
            quota: {
                usage: quotaStatus.usage || 0,
                limit: quotaStatus.limit || 2500,
                remaining: quotaStatus.remaining || 2500,
                percentage: quotaStatus.percentage || 0
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error syncing bot quota:', error.message);
        next(error);
    }
});

/**
 * PUT /api/messages/bot/quota
 * Actualizar l√≠mite mensual del bot
 */
router.put('/bot/quota', authenticateToken, logAccess, async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { monthly_bot_limit } = req.body;
        
        // Validaciones
        if (!monthly_bot_limit || !Number.isInteger(monthly_bot_limit) || monthly_bot_limit < 0) {
            return res.status(400).json({
                success: false,
                message: 'monthly_bot_limit debe ser un n√∫mero entero positivo',
                code: 'INVALID_LIMIT'
            });
        }
        
        if (monthly_bot_limit > 50000) {
            return res.status(400).json({
                success: false,
                message: 'El l√≠mite m√°ximo permitido es 50,000 mensajes por mes',
                code: 'LIMIT_TOO_HIGH'
            });
        }
        
        const success = await MessageService.updateBotLimit(clientId, monthly_bot_limit);
        
        if (success) {
            // Obtener nuevo estado
            const newStats = await MessageService.getBotUsageStats(clientId);
            
            res.json({
                success: true,
                message: 'L√≠mite mensual del bot actualizado correctamente',
                quota: {
                    monthly_bot_limit,
                    current_usage: newStats.current_bot_usage,
                    remaining: newStats.remaining,
                    percentage: newStats.percentage
                }
            });
        } else {
            res.status(500).json({
                success: false,
                message: 'Error al actualizar el l√≠mite del bot',
                code: 'UPDATE_FAILED'
            });
        }
        
    } catch (error) {
        console.error('‚ùå Error updating bot quota:', error.message);
        next(error);
    }
});

/**
 * POST /api/messages/bot/quota/reset
 * Resetear contador de uso del bot (solo para testing/admin)
 */
router.post('/bot/quota/reset', authenticateToken, logAccess, async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const clientCode = req.user.clientCode;
        
        const { executeQuery } = require('../config/database-simple');
        
        // Reset del contador y fecha
        const today = new Date();
        const resetDate = new Date(today.getFullYear(), today.getMonth(), 1);
        
        await executeQuery(
            'UPDATE clients SET current_bot_usage = 0, bot_usage_reset_date = ? WHERE id = ?',
            [resetDate.toISOString().split('T')[0], clientId]
        );
        
        // Obtener nuevo estado
        const newStats = await MessageService.getBotUsageStats(clientId);
        
        res.json({
            success: true,
            message: 'Contador de uso del bot reseteado correctamente',
            quota: {
                usage: 0,
                limit: newStats.monthly_bot_limit,
                remaining: newStats.monthly_bot_limit,
                percentage: 0,
                resetDate: newStats.bot_usage_reset_date
            }
        });
        
        console.log(`üîÑ Manual bot quota reset for client ${clientCode}`);
        
    } catch (error) {
        console.error('‚ùå Error resetting bot quota:', error.message);
        next(error);
    }
});

/**
 * GET /api/messages/bot/quota/history
 * Obtener historial de uso del bot (mensajes enviados por d√≠a)
 */
router.get('/bot/quota/history', authenticateToken, logAccess, async (req, res, next) => {
    try {
        const clientId = req.user.id;
        const { days = 30 } = req.query;
        
        const { executeQuery } = require('../config/database-simple');
        
        // Obtener estad√≠sticas de mensajes del bot por d√≠a
        const history = await executeQuery(`
            SELECT 
                DATE(m.sent_at) as date,
                COUNT(m.id) as bot_messages_sent,
                COUNT(DISTINCT c.id) as conversations_active
            FROM messages m
            INNER JOIN conversations c ON m.conversation_id = c.id
            WHERE c.client_id = ? 
                AND m.is_from_bot = 1 
                AND m.sent_at >= DATE_SUB(NOW(), INTERVAL ? DAY)
            GROUP BY DATE(m.sent_at)
            ORDER BY date DESC
        `, [clientId, parseInt(days)]);
        
        // Calcular totales
        const totalBotMessages = history.reduce((sum, day) => sum + day.bot_messages_sent, 0);
        const avgPerDay = history.length > 0 ? Math.round(totalBotMessages / history.length) : 0;
        
        res.json({
            success: true,
            history,
            summary: {
                total_days: history.length,
                total_bot_messages: totalBotMessages,
                avg_per_day: avgPerDay,
                period_days: parseInt(days)
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error getting bot quota history:', error.message);
        next(error);
    }
});

// ============================================================================
// TESTING ENDPOINTS - FUNCIONALIDADES PREMIUM
// ============================================================================

router.get('/test-premium', async (req, res) => {
    try {
        const clientId = req.user.id;
        const { executeQuery } = require('../config/database');
        
        // Test templates directo
        const templates = await executeQuery('SELECT * FROM message_templates WHERE client_id = ? LIMIT 5', [clientId]);
        const templatesProcessed = templates.map(t => {
            if (t.variables) {
                try {
                    t.variables = JSON.parse(t.variables);
                } catch (e) {
                    t.variables = [];
                }
            }
            return t;
        });
        
        // Test contactos directo
        const contacts = await executeQuery('SELECT * FROM contacts WHERE client_id = ? LIMIT 5', [clientId]);
        
        // Test etiquetas directo
        const tags = await executeQuery('SELECT * FROM contact_tags WHERE client_id = ? LIMIT 5', [clientId]);
        
        res.json({
            success: true,
            message: 'üéâ Funcionalidades Premium Funcionando',
            data: {
                templates: {
                    count: templatesProcessed.length,
                    sample: templatesProcessed.slice(0, 2)
                },
                contacts: {
                    count: contacts.length,
                    sample: contacts.slice(0, 2)
                },
                tags: {
                    count: tags.length,
                    sample: tags
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error testing premium:', error.message);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

module.exports = router;